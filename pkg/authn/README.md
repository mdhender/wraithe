# authn

`authn` provides an authentication service.

Identity is entangled with authentication.

Security is important to us, but not critical.
If it is critical to you, you must find a better service (something like Auth0).

## Authentication
This service can be used for identifying end-users or services.
We'll call both "users" to keep things simpler.

To successfully authenticate, the user must provide an `Identity` and a `Secret`.

Users must provide two pieces of information to identify themselves.
The first is their `Identity`.
This is a unique value that is only used for identification.
The second is their `Secret`.
The secret is hashed and compared to the stored value.

A valid identification token is returned only if both the `Identity` and `Secret` match the stored values.

The token can be presented as a cookie or bearer token in future challenges.

# Identity
We store the identification information in an `Identity` record.

    Identity {
        Id           string
        UserId       string
        HashedSecret []byte
    }

The `Id` is a unique identifier for the account.
This value is returned with the token.

The `UserId` is another unique identifier for the account.
The UserId is used to find the `Identity` record.
It is not returned to the caller.

The `HashedSecret` is stored in the `Identity` record.

# Signing Keys
Signing keys are used to verify that the token was generated by this service.

Signing keys are defined as a map of keys:

    SigningKeys map[KeyId]*SigningKey

The service is initialized with this map of signing keys and the amount of time that generated tokens are valid for.

## Signing Key
Each key is defined as a structure containing a unique identifier for the key, the key in plain text, and the moment that the key expires.

    SigningKey {
        KeyId     string
        PlainText string
        ExpiresAt time.Time
    }

The `KeyId` is a unique identifier for the key.
You shouldn't re-use keys.

The `PlainText` field stores the key value as plain text.
It's not encrypted, so please protect it.

The `ExpiresAt` field is always UTC.

When a key expires, all tokens that were signed with it become invalid.

The service will not create a token from an expired key or set the time-to-live for the token to extend beyond the key's `ExpireAt` value.

## Time to Live
The amount of time that tokens are valid for is defined as a duration:

    TimeToLive time.Duration

# Token
Tokens are returned by the service.

    Token {
        Id        string
        ExpiresAt time.Time
        KeyId     string
        Signature []byte
    }

In our implementation, the Token.String() function:
1. Obtains a signing key and sets the KeyId field
2. Sets the ExpiresAt (always as UTC)
3. Signs the token using the `Id`, `ExpiresAt`, and `KeyId` fields
4. Marshals the token to JSON
5. Encodes the JSON as Base64
6. Returns the resulting string

## Implementation Details
1. The service won't generate a token with a TTL that exceeds the lifetime of the signing key.
2. The service will not generate tokens from expired signing keys.
3. The service will delete signing keys from the map when they expire.
4. The service will pick signing keys at random from the map.
There is no such thing as a "preferred key."

